<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<body>
<div th:id="${graphId} + '-explorer-wrapper'" th:fragment="explorer" class="d-flex flex-column h-100">
    <!-- Graph Section -->
    <div th:id="${graphId} + '-graph-visualization'" class="flex-grow-1"
         style="position: relative; overflow: hidden; min-height: 400px;"></div>

    <script th:inline="javascript">
        {
            let graphData = /*[[${graphData}]]*/ null;
            const graphId = /*[[${graphId}]]*/ 'default';
            const elem = document.getElementById(graphId + "-graph-visualization");
            const searchForm = document.getElementById(graphId + "-search-form");
            const clearBtn = document.getElementById(graphId + "-clear-btn");
            const recenterBtn = document.getElementById(graphId + "-recenter-btn");

            const getGroupColor = (node) => {
                if (node.color) return node.color;
                const group = parseInt(node.group, 10) || 0;
                const base = Math.floor(group / 10);
                const variant = group % 10;
                const hue = (base * 137.5) % 360;
                const lightness = Math.min(90, 50 + (variant * 10));
                return node.color = `hsl(${hue}, 70%, ${lightness}%)`;
            };

            // Helper: Merge new data into the existing graph
            const expandNode = (node) => {
                const nodeId = node.id;
                fetch(`/discovery/explore?nodeId=${encodeURIComponent(nodeId)}`)
                    .then(res => res.json())
                    .then(newData => {
                        const {nodes, links} = Graph.graphData();
                        const existingNodeIds = new Set(nodes.map(n => n.id));
                        const uniqueNewNodes = newData.nodes.filter(n => !existingNodeIds.has(n.id));

                        Graph.graphData({
                            nodes: [...nodes, ...uniqueNewNodes],
                            links: [...links, ...newData.links]
                        });
                    })
                    .catch(err => console.error("Expansion failed", err));
            };

            // Helper: Remove a node and its connections
            const pruneNode = (node) => {
                const {nodes, links} = Graph.graphData();
                const newNodes = nodes.filter(n => n.id !== node.id);
                const newLinks = links.filter(l => l.source.id !== node.id && l.target.id !== node.id);
                Graph.graphData({nodes: newNodes, links: newLinks});
            };

            // 1. Initialize Graph Instance
            const Graph = new ForceGraph(elem)
                .width(elem.clientWidth)
                .height(elem.clientHeight)
                .nodeId('id')
                .nodeVal('size')
                .nodeRelSize(8)
                .nodeLabel('label')
                .nodeColor(getGroupColor)
                .linkSource('source')
                .linkTarget('target')
                .onNodeClick(expandNode)
                .onNodeRightClick(pruneNode)
                .nodeCanvasObject((node, ctx, globalScale) => {
                    const label = node.type;
                    const values = node.values || [];
                    const fontSize = 12 / globalScale;
                    ctx.font = `${fontSize}px Sans-Serif`;

                    // 1. Draw Circle
                    const r = 8; // Fixed radius or use (node.size * scalar)
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, r, 0, 2 * Math.PI, false);
                    ctx.fillStyle = getGroupColor(node);
                    ctx.fill();

                    // 2. Level of Detail: Only show text when zoomed in
                    if (globalScale >= 0.8) {
                        // Draw Label (NodeType) above circle
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.fillStyle = getGroupColor(node);
                        ctx.fillText(label, node.x, node.y - r - 2);
                    }

                    // 3. Level of Detail: Only show values when zoomed in further
                    if (globalScale >= 1.2) {
                        ctx.textBaseline = 'top';
                        ctx.fillStyle = 'black';
                        values.forEach((val, i) => {
                            ctx.fillText(val, node.x, node.y + r + 2 + (i * fontSize));
                        });
                    }

                    node.__r = r; // Store radius for pointer area
                })
                .nodePointerAreaPaint((node, color, ctx) => {
                    ctx.fillStyle = color;
                    const r = node.__r || 8;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, r, 0, 2 * Math.PI, false);
                    ctx.fill();
                })
                .linkCanvasObjectMode(() => 'after')
                .linkCanvasObject((link, ctx) => {
                    const MAX_FONT_SIZE = 4;
                    const LABEL_NODE_MARGIN = Graph.nodeRelSize() * 1.5;

                    const start = link.source;
                    const end = link.target;
                    const label = link.type;

                    // ignore unbound links
                    if (typeof start !== 'object' || typeof end !== 'object') return;

                    //ignore links with no type label
                    if (label === undefined) return;

                    // calculate label positioning
                    const textPos = Object.assign(...['x', 'y'].map(c => ({
                        [c]: start[c] + (end[c] - start[c]) / 2 // calc middle point
                    })));

                    const relLink = {x: end.x - start.x, y: end.y - start.y};

                    const maxTextLength = Math.sqrt(Math.pow(relLink.x, 2) + Math.pow(relLink.y, 2)) - LABEL_NODE_MARGIN * 2;

                    let textAngle = Math.atan2(relLink.y, relLink.x);
                    // maintain label vertical orientation for legibility
                    if (textAngle > Math.PI / 2) textAngle = -(Math.PI - textAngle);
                    if (textAngle < -Math.PI / 2) textAngle = -(-Math.PI - textAngle);

                    // estimate fontSize to fit in link length
                    ctx.font = '1px Sans-Serif';
                    const fontSize = Math.min(MAX_FONT_SIZE, maxTextLength / ctx.measureText(label).width);
                    ctx.font = `${fontSize}px Sans-Serif`;
                    const textWidth = ctx.measureText(label).width;
                    const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.2); // some padding

                    // draw text label (with background rect)
                    ctx.save();
                    ctx.translate(textPos.x, textPos.y);
                    ctx.rotate(textAngle);

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(-bckgDimensions[0] / 2, -bckgDimensions[1] / 2, ...bckgDimensions);

                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = 'darkgrey';
                    ctx.fillText(label, 0, 0);
                    ctx.restore();
                });

            // Physics Configuration to reduce clutter
            Graph.d3Force('charge').strength(-400); // Stronger repulsion to push nodes apart
            Graph.d3Force('link').distance(150);    // Longer links for breathing room

            // 2. Handle Search (Direct access to Graph variable!)
            searchForm.addEventListener('htmx:afterRequest', (evt) => {
                if (evt.detail.successful && evt.detail.xhr.response) {
                    try {
                        const data = JSON.parse(evt.detail.xhr.response);
                        Graph.graphData(data);
                    } catch (e) {
                        console.error("Failed to parse graph data:", e);
                    }
                }
            });

            // Handle Clear
            clearBtn.addEventListener('click', () => {
                Graph.graphData({nodes: [], links: []});
            });

            // Handle Recenter
            recenterBtn.addEventListener('click', () => {
                Graph.zoomToFit(400);
            });

            // 3. Handle Resize
            new ResizeObserver(entries => {
                const width = entries[0].contentRect.width;
                const height = entries[0].contentRect.height;
                if (width > 0 && height > 0) {
                    Graph.width(width);
                    Graph.height(height);
                }
            }).observe(elem);

            // 4. Load Initial Data
            if (graphData) {
                Graph.graphData(graphData);
            }
        }
    </script>
</div>
</body>
</html>